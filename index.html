<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>Happy Birthday â¤ï¸</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: radial-gradient(circle at center, #1a0a2e, #05010a);
  font-family: "Segoe UI", "PingFang SC", sans-serif;
}

canvas {
  position: fixed;
  top: 0;
  left: 0;
}

#hint {
  position: fixed;
  bottom: 24px;
  width: 100%;
  text-align: center;
  color: rgba(255,255,255,0.75);
  font-size: 14px;
  letter-spacing: 1px;
}
</style>
</head>

<body>
<canvas id="canvas"></canvas>
<div id="hint">ğŸ™ åŒæ‰‹åˆå â†’ Happy Birthday ï½œ âœ‹ å‘å¤–å±•å¼€ â†’ ğŸ‚</div>

<script>
/* ================= åŸºç¡€è®¾ç½® ================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
resize();
window.addEventListener("resize", resize);

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

let particles = [];
let targetShape = null;
let phase = "idle"; // idle | text | cake

/* ================= å…‰ç²’ç³»ç»Ÿ ================= */
class Particle {
  constructor(x, y) {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.tx = x;
    this.ty = y;
    this.vx = 0;
    this.vy = 0;
  }

  update() {
    const dx = this.tx - this.x;
    const dy = this.ty - this.y;
    this.vx += dx * 0.02;
    this.vy += dy * 0.02;
    this.vx *= 0.85;
    this.vy *= 0.85;
    this.x += this.vx;
    this.y += this.vy;
  }

  draw() {
    ctx.beginPath();
    ctx.fillStyle = "rgba(255,200,255,0.85)";
    ctx.shadowBlur = 10;
    ctx.shadowColor = "#ffb3ff";
    ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

/* ================= æ–‡å­— / è›‹ç³•å½¢çŠ¶ ================= */
function generateTextShape(text) {
  const off = document.createElement("canvas");
  off.width = canvas.width;
  off.height = canvas.height;
  const octx = off.getContext("2d");

  octx.fillStyle = "#fff";
  octx.font = "bold 120px Segoe UI";
  octx.textAlign = "center";
  octx.textBaseline = "middle";
  octx.fillText(text, canvas.width / 2, canvas.height / 2);

  return extractPoints(octx);
}

function generateCakeShape() {
  const off = document.createElement("canvas");
  off.width = canvas.width;
  off.height = canvas.height;
  const octx = off.getContext("2d");

  const cx = canvas.width / 2;
  const cy = canvas.height / 2 + 40;

  octx.fillStyle = "#fff";
  octx.fillRect(cx - 120, cy, 240, 80);
  octx.fillRect(cx - 90, cy - 60, 180, 60);

  octx.beginPath();
  octx.moveTo(cx, cy - 100);
  octx.lineTo(cx, cy - 60);
  octx.strokeStyle = "#fff";
  octx.lineWidth = 6;
  octx.stroke();

  return extractPoints(octx);
}

function extractPoints(octx) {
  const img = octx.getImageData(0, 0, canvas.width, canvas.height).data;
  const pts = [];
  for (let y = 0; y < canvas.height; y += 6) {
    for (let x = 0; x < canvas.width; x += 6) {
      const i = (y * canvas.width + x) * 4;
      if (img[i + 3] > 128) pts.push({ x, y });
    }
  }
  return pts;
}

function morphTo(shape) {
  particles = [];
  for (let i = 0; i < shape.length; i++) {
    const p = new Particle(shape[i].x, shape[i].y);
    particles.push(p);
  }
}

/* ================= åŠ¨ç”»å¾ªç¯ ================= */
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (const p of particles) {
    p.update();
    p.draw();
  }
  requestAnimationFrame(animate);
}
animate();

/* ================= æ‰‹åŠ¿è¯†åˆ« ================= */
const video = document.createElement("video");
video.style.display = "none";
document.body.appendChild(video);

const hands = new Hands({
  locateFile: file =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

let lastDistance = null;

hands.onResults(results => {
  if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
    const l = results.multiHandLandmarks[0][0];
    const r = results.multiHandLandmarks[1][0];
    const dx = l.x - r.x;
    const dy = l.y - r.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (lastDistance) {
      if (dist < 0.1 && phase !== "text") {
        phase = "text";
        morphTo(generateTextShape("Happy Birthday"));
      }
      if (dist > 0.35 && phase === "text") {
        phase = "cake";
        morphTo(generateCakeShape());
      }
    }
    lastDistance = dist;
  }
});

const camera = new Camera(video, {
  onFrame: async () => await hands.send({ image: video }),
  width: 640,
  height: 480
});
camera.start();
</script>
</body>
</html>
